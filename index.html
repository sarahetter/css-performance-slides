<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>CSS Performance & What is the Browser doing?</title>

		<meta name="description" content="Talk originally made for Confoo 2016">
		<meta name="author" content="Sarah Etter">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<div class="slides">
				<section>
					<h1>CSS Performance & What is the Browser doing?</h1>
					<p>
						<small>by <a href="http://sarahetter.com">Sarah Etter</a> / <a href="http://twitter.com/SarahEtter_">@SarahEtter_</a></small>
					</p>
				</section>

				<section>
					<h2>Object Models</h2>
					<div class="object-model">DOM</div>
					<div class="object-model">CSSOM</div>

                    <aside class="notes">
                        <p>Once the browser loads in your html & css, it begins building objects that represent your site.</p>
                        <p>First off - DOM (Document Object Model). This is a tree structure that, if you have done any JS programming, you are very familiar with. Each element in your HTML is a node, and nodes have children. The DOM should be identical between browsers, however if you have incorrectly nested HTML each browser has a slightly different way of parsing through & attempting to correct errors, so there may be slight differences.</p>

                        <p>Once done dom, it creates the CSS Object Model. This is a model that is much like the DOM, but for CSS. It is a tree structure. It contains objects like: StyleSheetList, CSSStyleSheet, CSSStyleRule.</p>
                    </aside>
				</section>

				<section>
					<h2>Object Models</h2>
					<div class="object-model">DOM</div>
					<div class="object-model">CSSOM</div>
                    <div></div>
                    <div class="object-model">Render Tree</div>

                    <aside class="notes">
                        <p>After the browser has finished making the DOM and the CSSOM, it combines them both into another model called the Render Tree</p>

                        <p>The render tree is created by going through the DOM (things that actually exist on the website), and adding the CSS rules from the CSSOM to those DOM nodes.</p>

                        <p>Render tree doesn’t contain things that are hidden by css (display:none)</p>
                    </aside>
				</section>

                <section>
                    <h2>Render Tree - Digging Deeper</h2>
                    <ul>
                        <li>Style Sharing</li>
                        <li>CSS Rule Hash Tables</li>
                        <li>Ancestor Filters</li>
                    </ul>

                    <aside class="notes">
                        <p>How the render tree is created is fairly important.
                            The dom isn’t matched against every single CSS rule, because that would be insanely slow.
                            The browser uses different intermediate sorts / searches and data structures to make this matching faster.</p>
                        <p>A data structure is a way of organizing data. There are many different types of data structures, and they each have a different way of making the task of dealing with data more efficient.</p>

                        <p><strong>Style Sharing</strong> - simply means that a browser figures out which DOM elements share the exact same styles (for example, two li’s in the same list). This saves having to do the exact same work more than once.</p>

                        <p><strong>CSS Rule Hash tables</strong>. - A hash table (simply put) is an associative array. When creating a hash table, you feed the element you are adding into a hash function, which calculates an index to place that element at in the array. When matching elements from the DOM to this hashtable, you just do that backwards. SO find hash, and only look at elements in that spot in the array. Saves from looking at every other element in other indices.</p>

                        <p><strong>Ancestor Filters</strong> - the browser checks to see if this is part of a set. It uses something called a Bloom Filter. A bloom filter uses a large array, and sets all elements in array to one bit - 0. Then, when running elements through the filter, it uses another type of hash function, which gets a number of indices. Then the original bits in the index at those indices are set to 1. So when checking against this filter, you can know for sure if your element matches - if all of it’s hash indexes are 1, then it may be in the set. If any of them are 0, then it is definitely not in the set. This narrows down how many selectors the browser has to compare against.</p>

                        <p>Each browser uses any or all of these, and their exact implementation may be different. There may be some other efficiencies added!</p>

                    </aside>

                </section>


                <section>
                    <h2>Rendering</h2>
                    <div class="object-model">Layout</div>
                    <div class="object-model">Paint</div>
                    <div class="object-model">Composite</div>

                    <aside class="notes">
                        <p>Once render tree is done, the browser does the actual rendering. These steps are Layout, Paint, and Composite.</p>
                    </aside>
                </section>

                <section>
                    <h2>Layout (aka Reflow)</h2>
                    <ul>
                        <li>Creates the layout of the site</li>
                        <li>Takes all positioning and sizing rules and creates a box-only layout of the site.</li>
                        <li>Calculates number of lines for text and uses line height</li>
                        <li>Recursive process</li>
                    </ul>
                    <aside class="notes">
                        <p><strong>Recursive process</strong> -
                        First finds width of parent, then loops down to the deepest node, and finds it’s size & positioning, then goes up through the tree.</p>
                        <p>This is why when you have a fixed height and width on a parent, if the contents are larger they overflow.</p>
                        <p>The deeper your DOM, the longer this process takes.</p>
                    </aside>
                </section>
                <section>
                    <h2>Layout Visualization</h2>
                    <iframe src="https://www.youtube.com/embed/ZTnIxIA5KGw" frameborder="0" allowfullscreen></iframe>
                    <aside class="notes">
                        At the end - the flash, there is a layout invalidation, so it has to reflow
                    </aside>
                </section>
                <section>
                    <h2>Layout Invalidations</h2>
                    <ul>
                        <li>Manipulating DOM tree (JavaScript)</li>
                        <li>Hiding things (adding display: none)</li>
                        <li>Resizing window</li>
                        <li>Changing the font</li>
                        <li>Adding or removing a stylesheet</li>
                        <li>Content changes</li>
                        <li>Activation of CSS pseudo classes</li>
                        <li>Manipulating the class attribute</li>
                        <li>Calculating offsetWidth and offsetHeight</li>
                        <li>And more...</li>
                    </ul>
                    <aside class="notes">
                        <p>So whenever you do these things, the browser will have a higher workload, and your website may encounter some “jank” or lower performance.</p>
                        <p>When images are loaded & the browser knows what size they are, it causes the browser to go through layout / reflow and paint cycle again. This is why you should set width and height attributes on images.</p>
                    </aside>
                </section>
                <section>
                    <h2>Paint</h2>
                    <ul>
                        <li>Browser creates layers and adds the colours to pixels and objects to these layers.</li>
                        <li>Not actually on the page yet.</li>
                        <li>Browser sends layer to the CPU or in some cases GPU</li>
                        <li>Processor creates the texture (bitmap final image) to be displayed on the page</li>
                    </ul>
                    <aside class="notes">
                        GPU - 3d transforms, anything with will-change css property set.
                    </aside>
                </section>
                <section>
                    <h2>Composite</h2>
                    <ul>
                        <li>Taking the painted layers and placing them on the previously calculated layout.</li>
                    </ul>
                    <aside class="notes">
                        This is the least computationally heavy action.
                    </aside>
                </section>
                <section>
                    <h2>So what does this all mean?</h2>
                    <div class="fragment">
                        <pre><code class="hljs css">
.person {
    color: blue;
}

div.wrapper > div.tagDiv > div.tagDiv.layer2 >
ul.tagUL > li.tagLi > b.tagB > a.TagA.link {
    color: blue;
}
                        </code></pre>
                    </div>
                    <aside class="notes">
                        <p>The Browser is doing most of the work for you.</p>
                        <p>Because of the work done & efficiencies added at the Render Tree creating stage, it is impossible to tell how each of your css rules will be parsed.</p>
                        <p>And as it turns out, the time it takes the browser to render different css selectors is negligible. (Ben Frain did a comparison in early 2014, and the biggest difference in time with a humonguous DOM using all insane selectors where every element is qualified with a class, along with multiple adjacent selectors and child selectors OR a simple class selector was 13 milliseconds).</p>
                        <p>It isn’t your job to write the css structure for the browser. It’s the browser’s job to make it efficient. Each engine does things a bit differently, so trying to guess how it will split up your selectors is futile.</p>
                        <p>The two selectors shown will have very negligible time differences in the browser rendering, unless the second is used for every element. However, one is way more semantic and easier to write.</p>
                    </aside>
                </section>

                <section>
                    <h2>So what can I do?</h2>
                    <ul>
                        <li>Two categories:
                            <ol>
                                <li>Load-time Optimization</li>
                                <li>After Load Optimization</li>
                            </ol>
                        </li>
                    </ul>
                    <aside class="notes">
                        There are limited things you can do to help load behaviour, but the major thing to know about CSS performance
                        is that it's not just about loading quickly, it's about how your site actually feels while using it. When there
                        are 'hiccups' in rendering, this is called jank. For example: when images load slowly, and layout is triggered, it makes
                        your site feel clunky.
                    </aside>
                </section>

                <section>
                    <section>
                        <h2>Load-time Optimization</h2>
                        <ul>
                            <li>Stylesheet Size</li>
                            <li>Critical CSS</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Stylesheet Size</h3>
                        <ul>
                            <li>UnCSS - grunt tool that uses PhantomJS</li>
                            <li>Less specific, more modular code (Easier to maintain, too!)</li>
                            <li>In general: Write as little css as possible</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Critical CSS</h3>
                        <ul>
                            <li>Inline above the fold CSS</li>
                            <li>critical grunt tool - finds critical css for you</li>
                            <li>Warning: inline won’t be cached as css in the browser</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <h2>After Load Optimization</h2>
                        <p>Considerations:</p>
                    <ul>
                        <li>Scrolling</li>
                        <li>Animations</li>
                        <li>Interactions</li>
                    </ul>

                    <aside class="notes">
                        <p><strong>Jank!</strong>
                        To move things - always use transform: translate.
                        http://csstriggers.com/</p>

                        <p>Interactions - CSS invalidation!</p>
                        <p>Click on nav, if add “active” class to whole body, then ALL css is invalidated & need to do layout, paint, composite again. Want to only invalidate the smallest chunk possible.</p>

                        <p>Animations - CSS always! ORRRR if must use Javascript -  use requestAnimationFrame - allows browser to figure out when the best time to move things on the page is, along with other layout & painting tasks. Also saves battery of user, as with setTimeout the animation is always happening, even when the animation is in a background tab.</p>
                    </aside>
                </section>

                <section>
                    <h2>Expensive Styles</h2>

                    <ul>
                        <li>Some styles take a slightly longer time to render initially
                        <ul>
                            <li>box-shadow</li>
                            <li>border-radius</li>
                            <li>transparency (opacity and rgba/hsla)</li>
                            <li>transform</li>
                            <li>css filters</li>
                        </ul>
                        </li>
                    </ul>
                    <aside class="notes">
                        <p>Notice that these are all fairly new properties. Render time may improve, as well as it's important to just use these
                        sparingly.</p>
                    </aside>
                </section>

                <section>
                    <section>
                        <h2>Chrome Devtools Monitoring</h2>

                        <ul>
                            <li>Rendering Tab</li>
                            <li>Timeline</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Rendering Tab</h3>
                        <ul>
                            <li>Enable Paint Flashing</li>
                            <li>Show FPS meter</li>
                            <li>Show scrolling perf issues</li>
                            <li>Show layer borders</li>
                        </ul>
                        <aside class="notes">
                            <p>Enable paint flashing - click on, go to http://www.cnn.com/ (Entire Window flashes, indicating a lot of full invalidation) VS. https://www.reddit.com/  - can see when individual things are painted on load. Then show difference in scrolling, how reddit flashes and cnn doesn’t. CNN scroll is a much better, less janky experience, even though reddit doesn’t have a lot to it - just text, small thumbnails.</p>

                            <p>Show FPS meter - looking for 60 FPS</p>

                            <p>Show scrolling perf issues - http://www.nytimes.com/ (shows mousewheel event listener) in top corner</p>

                            <p>Show layer borders - show in own presentation. Want to make layers small. Also notice that paint doesn't occur on animation, but on end of state when another class is added.</p>
                        </aside>
                    </section>
                    <section>
                        <h3>Timeline</h3>
                        <ul>
                            <li>Record Timeline</li>
                            <li>Watch for long paint times</li>
                            <li>Diagnose the issue</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <h1>Questions?</h1>
                </section>







			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
